# JavaScript

## 基础

### 运算符

JavaScript 有两种比较方式：严格比较运算符和转换类型比较运算符。对于严格比较运算符（===）来说，仅当两个操作数的类型相同且值相等为 true，而对于被广泛使用的比较运算符（==）来说，会在进行比较之前，将两个操作数转换成相同的类型。对于关系运算符（比如 <=）来说，会先将操作数转为原始值，使它们类型相同，再进行比较运算。

字符串比较则是使用基于标准字典的 Unicode 值来进行比较的。

转换类型比较运算符（==和!=）使用抽象相等比较算法比较两个操作数。可以大致概括如下：

* 如果两个操作数都是对象，则仅当两个操作数都引用同一个对象时才返回true。

  如果一个操作数是null，另一个操作数是undefined，则返回true。
  如果两个操作数是不同类型的，就会尝试在比较之前将它们转换为相同类型：

* 当数字与字符串进行比较时，会尝试将字符串转换为数字值。
  如果操作数之一是Boolean，则将布尔操作数转换为1或0。
  如果是true，则转换为1。
  如果是 false，则转换为0。

* 如果操作数之一是对象，另一个是数字或字符串，会尝试使用对象的valueOf()和toString()方法将对象转换为原始值。

* 如果操作数具有相同的类型，则将它们进行如下比较：
  String：true仅当两个操作数具有相同顺序的相同字符时才返回。
  Number：true仅当两个操作数具有相同的值时才返回。+0并被-0视为相同的值。如果任一操作数为NaN，则返回false。
  Boolean：true仅当操作数为两个true或两个false时才返回true。



## 原型链

## 原型和原型链

JS是基于原型的编程，属于OOP一种，JS通过原型实现实例对象创建，通过原型链实现继承

### 原型链继承

```javascript
// 寄生组合
function A() { }
function B() {
	A.call(this)
}
B.prototype = Object.create(A.prototype)
B.prototype.constructor = B
```



## 闭包

解释1：函数对象通过作用域链相互关联起来，函数内部变量都可以保持在函数的作用域中，有权访问另一个函数作用域中的变量。

解释2：一个绑定执行环境的函数。

使用：

模拟私有方法

*在性能考量方面避免过度使用闭包，闭包在处理速度和内存使用都有负面影响，可能还会导致内存泄露。*

## 函数式编程



## ES6

ECMASript2015简称

### Promise

[Promise自定义](./Promise.md)



## TypeScript



